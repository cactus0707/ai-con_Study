ㅇ 추상화된 메모리 모델만 이해하고, 더 상세히 추상화된 내용 (v8orgㅇ나 다른 마소나 등등, 의 엔진은 추후에 보도록함.. 너무 깊을 필요가 없음)
자바스크립트는 변수 영역과 데이터 영역, 그 객체의 변수 영역 (tree way 변수 영역-> ... -> ... )으로 변수 영역을 만들고,

데이터 영역은 한곳에 모아두고 cpp리터럴 풀링 처럼 데이터를 쓰려고함. ( GC있는 언어들의 특징.)
데이터 수정시 에는 재할당을 해버리고, 이전 데이터가 참조 받는 곳이 없으면 GC 에 의해 지워짐.


data type : 
    ㅇPrimitive type // Number,String,Boolean,null, 
    undefined(V8엔진이 자동으로 부여해주는 언디파인드만 쓰려고 할 것. 왠만해선 널로 작성),Symbol

    ㅇRefernece : Object - Array, Function, Date, Regexp, Map, WeakMap, Set, WeakSet.


변수와 상수 : 한번 데이터 할당이 이루어진 변수 공간에 다른데이터를 재할당 할수 있는지 관건 // 상수같은 경우 아마 RO화 시켜놓을 것. -- 변수 영역의 메모리가 관건.
불변성 여부 판단 : 데이터 영역의 메모리가 관건.
        불변값과 가변값
        변수 영역에서 데이터 영역으로 첫번째 참조에서, 이, 데이터 영역에서 다른 참조가 있을 수 있고, 값이 저장된 경우가 있을 수 있음
        값이 저장된 경우, 값을 수정하지 않고, 재햘당 하면서 쓰되 GC당하지 않는한, 한번 만들어진 값은 변하지 않음. 이것을 불변값. 내지는 불변성

        가변값:
        우선, 원시타입은 모두 불변값이고, 객체 타입은 불변값이거나, 가변값임.
        지금 case는 객체의 가변성? 가변값에 대한 이야기
        - 우선 원시타입에서 보듯이 데이터 영역에 값이 들어가 있으면 불변성을 띄는데, 객체의 경우 그 객체의 변수 영역을 할당함.
        이때, 그 객체의 변수 영역이 바뀔수 있다는 점이 가변성이 있다라고 얘기함. // 객체의 경우도 데이터는 첫번째 참조했던 데이터 영역에서 값을 씀(객체의 변수 영역에서 참조를 통해)

복사(shallow / deep) - 복사의 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일 / 그러나 객체의 경우 한번의 참조가 더 일어 나므로 행동이 다를 것.
    ㅇshallow 
        shallow 카피의 경우, 참조 하는 대상이 변경 되었을 때, 다른 쪽에서 참조하고 있다면 값이 같이 변경되어버림 // 데이터가 신뢰 할 수 없게 됨.
        var a=b , var obj1=obj2  같은 경우 할당이 아니라, javascript는 복사가 일어남(참조 방식으로 같은 데이터 영역을 바라보게됨). 
        쉽게 말해 바로 아랫단계 복사 /
    ㅇdeep
        객체의 경우 모든 값들을 찾아서 그 내부의 영역 까지 가서 ( 데이터 영역을 가르키는 곳 까지 리커시브하게 들어가) 그 데이터 영역의 값을 전부 복사.


undefined & null
        자바 스크립트엔진은 사용자가 응당 어떤값을 지정 했을 거라고 생각을 했는데(예상을 했는데), 실제로 그렇지 않았을 때 undefined를 부여해주는
        1.값을 대입하지 않은 변수
        2.객체 내부의 존재하지 않는 프로퍼티에 접근하려 할 때
        3.Return문이 없거나 호출되지 않는 함수의 실행 결과

        --->비어 있는 요소는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외 된다.
  
        undefined 는 어떤 변수에 값이 존재하지 않음을 의미, 
        (undefined라는 값을 할당할 경우와 아닌 경우가 생김.. 햇갈리지 않기 위해 값이 없을떈 항상 null을 써야함) 
        null은 명시적으로 없음을 표현하기 위해 대입.

        비어있음을 명시적으로 나타내야할 때는 null을 써라!
            -type of null 은 object :javascript 자체 버그
            어떤 변수 값이 null인지 아닌지 판단하기 위해선, typeof 대신 다른 방식으로 접근해야함.

유성님 Feedback // 
==은 쓰지마라. 타입 세이프 하지않다는 내용인 것 같음.
===을 쓰고 정확히 비교를 하라.







